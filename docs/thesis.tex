% Document settings and packages
\documentclass[a4paper,12pt]{report}
	\usepackage[utf8]{inputenc}
	\usepackage{graphicx}
	\usepackage{hyperref}
	\usepackage{url}
	\usepackage{geometry}
	\usepackage[acronym]{glossaries}
	\graphicspath{{figures/}}
	\usepackage{listings}
	\usepackage{color}
	\usepackage{xcolor}
	\usepackage{caption}
	\usepackage{setspace}

\doublespacing
\newcommand{\quotes}[1]{``#1''}
\renewcommand{\glsgroupskip}{}
	
% define listings style
\lstset{frame=bottomline,
   %aboveskip=3mm,
   %belowskip=3mm,
   showstringspaces=false,
   columns=flexible,
   basicstyle={\ttfamily},
   numbers=none,
   tabsize=4
}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

	
% Acronyms page
\makeglossaries
\newacronym{vpn}{VPN}{Virtual Private Network}
\newacronym{ip}{IP}{Internet Protocol}
\newacronym{ipv4}{IPv4}{Internet Protocol version 4}
\newacronym{ipv6}{IPv6}{Internet Protocol version 6}
\newacronym{tcp}{TCP}{Transmission Control Protocol}
\newacronym{udp}{UDP}{User Datagram Protocol}
\newacronym{gre}{GRE}{Generic Routing Encapsulation}
\newacronym{tls}{TLS}{Transport Layer Security}
\newacronym{ipsec}{IPsec}{Internet Protocol Security}
\newacronym{ssh}{SSH}{Secure Shell}
\newacronym{l2tp}{L2TP}{Layer 2 Tunneling Protocol}
\newacronym{osi}{OSI}{Open Systems Interconnection}
\newacronym{dtls}{DTLS}{Datagram Transport Layer Security}
\newacronym{mipv6}{MIPv6}{Mobile IPv6}
\newacronym{sa}{SA}{Security Association}
\newacronym{esp}{ESP}{Encapsulating Security Payload}
\newacronym{ah}{AH}{Authentication Header}
\newacronym{spd}{SPD}{Security Policy Database}
\newacronym{sad}{SAD}{Security Association Database}
\newacronym{pad}{PAD}{Peer Authorization Database}
\newacronym{spi}{SPI}{Security Parameter Index}
\newacronym{isakmp}{ISAKMP}{Internet Security Association and Key Management Protocol}
\newacronym{icv}{ICV}{Integrity Check Value}
\newacronym{ike}{IKE}{Internet Key Exchange}
\newacronym{iana}{IANA}{Internet Assigned Numbers Authority}
\newacronym{nat}{NAT}{Network Address Translation}
\newacronym{iv}{IV}{Initialization Vector}
\newacronym{aes}{AES}{Advanced Encryption Standard}
\newacronym{hmac}{HMAC}{Keyed-Hash Message Authentication Code}



\begin{document}
	% title page
	\begin{titlepage}
		\newgeometry{top=15mm}
		\begin{center}
			\vspace{-10in}
			{\LARGE University of Bucharest \\
			Faculty of Mathematics and Computer Science }
			\vfill
			{\Large Bachelor's Thesis} \\
			\vspace{10mm}
			\textbf{\Huge Secure Network Communications} \\
			{\LARGE Bogdan Ionescu} \\
			\vspace{20mm}
			\begin{flushleft}{\large Supervisor \\
			Lect. Dr. Eng. Paul Irofti}
			\end{flushleft}
			\vfill
			July, 2020
		\restoregeometry
		\end{center}
	\end{titlepage}
	\author{Bogdan Ionescu}
	\date{\today}
	
	% abstract page
	\begin{abstract}
		This thesis aims to describe different potential security vulnerabilities when using public networks, such as the Internet, as well as suitable methods on how they can be resolved. The first chapter presents the dangers one might encounter while traversing public networks and how VPNs make use of tunneling protocols to mitigate them. We then take a deep dive into IPsec, a very popular and adaptable network protocol suite designed to address a plethora of security needs for both casual users and businesses. Finally, a software application written in the Go programming language is outlined, with the purpose of demonstrating how securing network traffic would be implemented.
	\end{abstract}		
	
	% contents
	\tableofcontents
	
	% Print acronyms page
	\setlength{\glsdescwidth}{\hsize}
	\glsaddall
	\printglossary[type=\acronymtype,nonumberlist]
	
	\chapter{Introduction}
	
	\section{Security Over Networks}
		
	In this day and age, networking is everywhere, especially considering the exceedingly fast expansion of the Internet. The Internet, the ultimate network of networks, has radically changed our day-to-day life. Just several years ago, simple everyday habits, such as quickly searching for a piece of information on Google, online shopping, streaming your favorite songs or paying your bills with just a few clicks would have seemed possible only in a distant future. And yet here we are today, achieving even more impressive tasks, making use of all kinds of networks available within our laptops, phones, tablets and even home electronics, thanks to the IoT.
		
		Unfortunately, the Internet's rapid development also comes with a few important drawbacks which are regrettably often overlooked --- the most significant one being cybersecurity. \textit{Cybersecurity} is the protection of computer systems and networks from the theft and damage of hardware, software or electronic data, as well as from the disruption of the services they provide. Most often, networks, full of information, are the first frontier when trying to exploit systems,  which is why network security represents such an important key aspect against cybercrime.
		
		Inevitably, when having any communication over the Internet, a significant amount of data is being sent between you (more precisely, your device) and the other party, commonly a server or another person's device. Although this data can sometimes be quite harmless, such as a quick Google search for a cake recipe or just streaming some music, in some cases it may contain more sensitive and valuable information than you can think of. Personal messages while chatting with a close friend, credit card information when making an online payment, passwords used when logging in to different websites, the video feed recorded by your webcam when having an online conference --- these are only just a few examples of what kind of infomation leaves your private home network when accessing the Internet. Since the Internet is a public network, such data can be easily intercepted by other parties before reaching its destination, which often leads to catastrophic consequences.
		
		By now you might think that if you are using an application which encrypts its data, you should be safe on the Internet. Unfortunately, this is often not the case, as there are many places where things can go wrong. For example, in many messaging systems, messages pass through intermediary parties, such as the application's servers, which store them, from where they are retrieved by the recipient. In such scenarios, data is generally encrypted only in transit --- from the sender to the server, and from the server to the destination. Even if the servers encrypt the data at rest (which, surprisingly, does not always happen), they still must have access to the cryptographic keys used in this process, therefore information is still being vulnerable in case the actual servers are being targeted. Moreover, this allows the third party, or any other organization which has a backdoor to these servers, to freely recognize our data. Such invasion of privacy is prevented by using end-to-end encryption, a system where only the communicating users can read the messages, denying any other third party to access the cryptographic keys needed to decrypt the information.
		
		Even if such encryption is used, with strong cryptographic ciphers, unlikely to be broken in attacks, we still might experience some troubles. Application data that leaves our home network, in order to be routed over networks, will have an \acrfull{ip} header added to it, which contains our public IP address and the destination IP address. These are unique, ISP-issued addresses which can be used to monitor and censor traffic, since every service we try to access will be identified by its IP address. This could also lead to IP address-based geo-blocking and IP range ban, methods often employed by media companies, governments, intelligence agencies and many others.
		
		So far we have only talked about the consequences from the point of view of a casual user, but damages rise significantly in the case of cyber attacks against major businesses, usually leading to huge amounts of loss in revenue. In fact, Juniper Research estimated that the average cost of a data breach in 2020 will exceed \$150 million, as more business infrastructure gets connected \cite{juniper}. In order to mitigate cyber attacks, they usually maintain one or more private networks inside their offices and only from within these controlled networks employees can access necessary resources. Such resources can actually be part of the same network, thus making transfer of data safe, since everything happens inside the private network, but inevitably some resources, such as cloud services, will be accessed through the Internet. Some employees must also be able to connect to the private network through the Internet even if they are part of another network, in order to access its resources, possibly in case of time-critical emergencies or just to work remotely from their homes. Therefore, many companies need a technology that allows secure communication between their private network and another host across a public network, or even to another different private network, such as communication between two private networks owned by different offices of the same company, located in distant regions.
		
		The solution to all the aforementioned problems, and to many other vulnerabilities while using a public network, is a \acrfull{vpn}.
		
		\section{What Is a Virtual Private Network?}
		Security over networks is usually described by three components: confidentiality, integrity and authenticity. Confidentiality, often achieved by encryption, guarantees that data can only be understood by authorized entities. Integrity ensures that the data has not been modified between these endpoints. Finally, authenticity proves that data originated from an authorized party, and not from another source. Apart from these three, another concept which is often massively desired over public networks refers to anonimity, which assures that information we send out does not divulge our identity. All of these can be achieved by VPNs, if implemented correctly.
		
		A \acrfull{vpn} extends a private network by allowing hosts which are not part of it to send and receive data over a public network, usually the Internet, as if they are directly connected to the private network. VPNs are build by establishing a virtual link of communication between two nodes, one being part of the private network. The second node will forward its traffic to it, the first node acting like a proxy, therefore appearing as the traffic actually originated from within the private network from which it is part of. Since encryption is a common, yet not an inherent part of a VPN connection, this channel of communication is usually called a \textit{tunnel} --- only the two endpoints being able to understand the data passing through it. 
		
		Classified by the type of topology of connections, defined by the location of the two endpoints, VPNs usually are of three types: site-to-site, point-to-point (sometimes also called host-to-host), which are the most common, and a combination of the two, point-to-site.
		
		Site-to-site VPNs, illustrated in figure \ref{fig:site-to-site_VPN}, establish a tunnel between two whole networks, therefore allowing any authorized host in any of the two networks to make use of it. Such architecture is frequently used by businesses to securely connect networks owned by the same company in different regions.
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{site-to-site_VPN}
			\centering
			\caption{In this site-to-site architecture, the two VPN devices establish a secure tunnel through the public network. Since traffic must be encrypted from one site to another, the two VPN endpoints, placed in this case after the routers, are responsible for securing data before it crosses the public network. VPN technology can also be directly embedded in routers, removing the need for two additional devices.}
			\label{fig:site-to-site_VPN}
		\end{figure}
		
		Advantages of site-to-site VPNs include scalability, being quite straightforward to add another site, or more devices inside one of the networks, and high availability, as the VPN tunnel does not depend on a device inside the network to initiate and maintain the secure connection. However, for regular users who wish to remain as private as possible, site-to-site VPNs have a quite serious disadvantage. Since traffic is secured just as it leaves the site, by the VPN device or router, data is still vulnerable in the network until it reaches this point, or after it was decrypted, at the other site. As a result, anyone who can intercept our traffic at these stages is a potential threat. Although this scenario is not likely to happen in a business office, it is very probable, for example, for someone who wishes to secure his data from a public place which offers free Internet connection, such as a coffee shop or restaurant.
		
		Point-to-point VPNs (figure \ref{fig:point-to-point_VPN}) establish a secure tunnel between two single hosts in usually separate networks, encryption and decryption taking place only at these points, therefore providing end-to-end encryption and eliminating the aforementioned risk present with site-to-site architectures.
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{point-to-point_VPN}
			\centering
			\caption{A point-to-point VPN tunnel between two hosts. The tunnel is usually initiated by one endpoint, but it is dependent on both; if one of the endpoints is down or unreachable, no tunnel can be established.}
			\label{fig:point-to-point_VPN}
		\end{figure}
		
		Point-to-point VPNs are used to form traditional consumer VPNs, where a user establishes a secure tunnel between his device and a server, which is then used as a proxy to access resources, possibly again through the Internet. If this traffic is intercepted, its origin could only be traced back to the proxy server, not the authentic source, which is the other endpoint of the tunnel. This can only be identified by those who have access to the proxy server, in addition to all the decrypted traffic routed through it. Although some VPN service providers claim that they do not log such traffic when clients use their servers, this sometimes is hard to believe. Such risks, along with the fact that VPN providers charge for their services, prompt users to rely on self-hosted VPNs, in which they own the proxy server. In this case, it is the user's job to install and manage the VPN software on both the proxy server and the other endpoint.
		
		\section{Tunneling Protocols}
		The two endpoints of a VPN tunnel do most of the work, being responsible with managing the tunnel and making sure that communication through it is possible. In order for it to actually function, they must modify the regular network packets received from the clients, making sure they are routed to the other endpoint, not to their actual destination, and also provide encryption, if desired. From an original network packet only important information is kept, usually either the network or the transport layer, discarding other layers. This fragment is often called the payload packet, because it is then used as a payload for the final packet. If encryption is used, some portion or the entire payload packet can be modified. This process of encapsulating a packet inside another packet is called \textit{tunneling}, achieved by \textit{tunneling protocols}.
		
		For example, IP in IP is a tunneling protocol which encapsulates an IP datagram within another IP datagram, as shown in figure \ref{fig:ip-in-ip_packet}. The source IP in the outer IP header will correspond to the entry point of the tunnel, while the destination IP will reveal the exit point, therefore guaranteeing that the packet will be routed to the other VPN endpoint. Except to the encapsulator decrementing the TTL field in the inner IP header, the packet payload remains unchanged during its delivery to the tunnel exit point. Once there, decapsulation takes place, removing the outer IP header and reconstructing the original packet, which will be sent to its original destination.
		\begin{figure}[h]
			\includegraphics[width=\textwidth,height=0.14\textheight,keepaspectratio]{original_ipv4_packet}
			\centering
		\end{figure}
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{ip_in_ip}
			\centering
			\caption{The original IPv4 datagram, with TCP as the upper layer protocol, and the corresponding IP in IP datagram.}
			\label{fig:ip-in-ip_packet}
		\end{figure}
		
		\acrfull{gre}, a protocol fairly similar to IP in IP, developed by Cisco Systems, and Layer 2 Tunneling Protocol (L2TP) are just another two examples of tunneling protocols frequently used. However, just like IP in IP, all of these protocols do not provide any confidentiality or integrity. They just encapsulate the data received, without modifying it in order to provide encryption. To achieve this, they generally rely on other protocols.
		
		Internet Protocol Security (IPsec), Transport Layer Security (TLS) and Secure Shell (SSH) are the most often used protocols for secure network services over an insecure network. A key difference between these three protocols is the OSI layer at which they operate. While IPsec is generally considered a network layer protocol, TLS and SSH depend on a reliable stream of bytes and are therefore implemented over TCP, making them layer 5 or above, or just application layer protocols in the TCP/IP suite. The fact that IPsec performs at a lower layer than the rest and it is not dependent on TCP increases its flexibility and capabilities, being able to secure any transport layer protocol, such as UDP. Datagram Transport Layer Security (DTLS) was also developed to implement TLS over UDP. Tunneling over UDP is sometimes preferred to avoid the TCP meltdown problem (also known as TCP over TCP), in which tunneling a TCP-encapsulating payload induces a dramatic loss in transmission performance (even up to 20\%)\cite{tcpmeltdown}. OpenSSH, an open source suite of secure networking utilities based on SSH avoids the meltdown by decapsulating and re-encapsulating TCP, only sending the payload through the tunnel \cite{opensshmeltdown}.
		
		IPsec, TLS and SSH use a wide variety of strong cryptographic algorithms, providing robust authentication, confidentiality and integrity, amongst many other services. All three of them support tunneling and are currently used to establish and maintain secure tunnels across many networks worldwide. However, the more complex IPsec is still the most viable and preferred option for tunneling, especially for site-to-site VPNs, while TLS and SSH are better for secure remote access, being more straightforward and easier to set up.
		
	\chapter{Internet Protocol Security}
	\section{Description }
		The goal of Internet Protocol Security (IPsec) is to provide security from the network layer, being used worldwide to deploy a variety of VPNs, therefore guaranteeing either secure traffic between networks or in case of remote access, or end-to-end security. It is also often used by other protocols (e.g. L2TP, MIPv6, GRE) to protect some or all of their traffic.
		
		IPsec is not a single protocol, but rather a set of network protocols, each one with critical and specific tasks, working together to achieve the main goal --- security over networks. The complex IPsec protocol suite can be broken into three essential parts which will be thoroughly explained in the next sections:
		\begin{itemize}
			\item \textbf{Security Associations} define the security attributes (such as cryptographic algorithms, keys, channel lifetime etc.) of a specific connection between two or more network nodes
			\item \textbf{Authentication Header} guarantees integrity of IP datagrams sent through the secure channel \cite{rfc4302}
			\item \textbf{Encapsulating Security Payload} assures confidentiality, which is achieved by applying encryption to IP datagrams. ESP can also be configured to employ integrity services, almost as effective as AH \cite{rfc2406}
		\end{itemize}
		
		IPsec has two main modes of operation which define how AH and ESP behave, namely \textbf{transport mode} and \textbf{tunnel mode}. When transport mode is used, only the IP payload is secured, by one or both security protocols. When employing IPsec in tunnel mode, the whole IP datagram (not just the payload) is encapsulated within another IP datagram, just like IP in IP. Therefore, IPsec in tunnel mode is generally used to form traditional VPNs.
		
		Although a decent part of the IPsec stack is already directly embedded into the Linux kernel, guaranteeing efficient packet processing with minimum overhead, some daemons are still required in user space, generally those regarding Security Associations.
		
	\section{Security Associations}
	IPsec provides data confidentiality and integrity through the two fundamental security protocols previously mentioned, the Authentication Header (AH) and Encapsulating Security Protocol (ESP). However, since a VPN device might handle many secure streams of data with different hosts at the same time, when an IP datagram employing AH and/or ESP arrives, how does it know which set of security parameters (cryptographic algorithm, keys, policies etc.) to use for that particular connection? Moreover, both AH and ESP support a wide variety of cryptographic ciphers, and therefore the two endpoints must agree beforehand on which exact algorithm to employ, and perhaps generate and exchange cryptographic keys. As you can see, many more security characteristics and policies must be negotiated and bound to a specific connection between entities before establishing and actually using an IPsec tunnel. This is the purpose of Security Associations. 
	
	A Security Association (SA) describes a set of attributes and management policies shared by two or more network entities, in order for them to create and maintain a secure channel of communication \cite{rfc2408}. Both AH and ESP (and other network protocols) greatly depend on SAs, because these dictate when the two protocols are employed, and in what fashion. The information contained by SAs is stored in one or more databases, which are interrogated by the IPsec system whenever a secure connection is desired. For this lookup, aside from the IP destination address and the security protocol used (AH and/or ESP), a Security Parameter Index (SPI) is required. The SPI is a randomly generated 32-bit value which identifies to which particular SA a given network packet should be bound, and is therefore a mandatory field in the ESP and AH headers, as we will see later.
	
	A model defined in RFC 4301 outlines three databases in order to store various SA information: the Security Policy Database (SPD), the Security Association Database (SAD), and the Peer Authorization Database (PAD) \cite{rfc4301}.
	
	\subsection{Security Policy Database}
		A Security Policy Database (SPD) specifies processing rules for both inbound and outbound IP datagrams handled by the device, deciding which can pass through, which can not and which must secured with IPsec. Therefore, the SPD can be considered a sort of firewall. For a given packet, three processing rules are defined and stored in the database:
		\begin{itemize}
			\item DISCARD: Packets that match this rule are not allowed to pass through the device, and will therefore be discarded by the kernel.
			\item BYPASS: Packets that match this rule are allowed to cross the IPsec boundary unchanged (without employing any security services).
			\item PROTECT: Packets that match this rule are afforded IPsec protection. In this case, the SAD is used to identify which security protocols to employ to the given packet (AH and/or ESP), along with any attributes they require (e.g. mode of operation, cryptographic algorithms).
		\end{itemize}
		
	\subsection{Security Association Database}
		To determine what to do with a particular datagram, a device first checks the SPD, in order to see if the datagram should be discarded, allowed to pass through unchanged or offered security services. If the latter is the case, the SAD is further interrogated to find the particular security mechanisms to be applied.
		
		More formally, a Security Association Database stores the parameters needed by AH or ESP in order to secure traffic. Therefore, an SAD entry includes the following fields \cite{rfc4301}:
	\begin{itemize}
		\item Security Parameter Index (SPI), used to match the same field present in the security header of the network packet.
		\item Sequence Number Counter, a 64-bit counter used in AH or ESP headers to guarantee protection against replay attacks.
		\item Sequence Counter Overflow, a flag which decides what happens when the sequence number counter overflows.
		\item Anti-Replay Window, a 64-bit counter also used for protection against replay attacks.
		\item AH integrity algorithm, key, etc.
		\item ESP encryption algorithm, key, mode, IV, etc.
		\item ESP integrity algorithm, keys, etc.
		\item Lifetime of the SA.
	\end{itemize}
	
	\subsection{Peer Authorization Database}
	The Peer Authorization Database (PAD) simply provides a link between the SPD and a security association management protocol which is actually responsible for creating SAs, such as IKE or KINK, along with other constraints and information related to their peers.
	
	
	\subsection{Internet Key Exchange}
		Internet Key Exchange (IKE) is one of the most often used protocols used to establish, negotiate, modify and delete Security Associations between IPsec nodes. Unlike AH and ESP, IKE is not directly embedded into the Linux kernel, and therefore a daemon in user space is required. Such applications generally implement IKE version 2 (IKEv2), an improvement over the initial IKE version 1 (IKEv1), addressing many of its weaknesses. A draft for IKE version 3 (IKEv3) exists, but it is not yet adopted.
		
		Since both AH and ESP almost always require an SA, IKE is the first protocol employed, representing an initial step towards a secure connection. In order to actually establish an IPsec SA, IKE goes through two phases. 
		
		IKE phase 1 decides how the involved peers will exchange further information securely. This is done with the help of an Internet Security Association and Key Management Protocol (ISAKMP) SA negotiation, which establishes a secure channel of communication for phase 2. During this ISAKMP session, the IPsec nodes are authenticated (by using either a pre-shared key, digital signature, or public key encryption \cite{rfc5996}), an encryption algorithm and hash algorithm are chosen, and a Diffie-Hellman group is created.
		
		In IKE phase 2 the secure tunnel previously established is used to safely negotiate the actual IPsec SA, where the parameters for AH and ESP are decided. 
		
		IKE is usually implemented over UDP on port 500.
		
		\section{Authentication Header}
		\subsection{Description}
		Authentication Header (AH) is one of the two core protocols of the IPsec suite. Its main objective is to provide integrity for IP datagrams, term which is used to embody two critical concepts:
		\begin{itemize}
			\item \textbf{Connectionless integrity} guarantees that the essential information contained within a packet has not been changed in transit, either by a malicious entity or due to errors
			\item \textbf{Data origin authentication} ensures the IP datagram originated from a trusted source
		\end{itemize}
		
		This is achieved by employing a cryptographic hash algorithm, used to compute an integrity check value (ICV) over the majority of the IP datagram. The calculated ICV is then added in an AH header which is inserted in the outgoing packet. The receiving IPsec device repeats the ICV computation, and compares it with the one in the AH header. If the two values differ, the packet was modified in transit and is discarded.
		
		\subsection{Format}
		The AH format (figure \ref{ah_header}) is quite simple, containing the following fields:
	\begin{itemize}
	\item Next Header (8 bits) identifies the next protocol used after AH. The value is chosen from the set of IP Protocol Numbers defined by IANA. For example, a value of 4 indicates IPv4, a value of 41 indicates IPv6, and a value of 6 indicates TCP.
	\item Payload Length (8 bits) specifies the length of the AH header in 32-bit words \cite{rfc4302}.
	\item Reserved (16 bits) is not currently used and it is set to zero. 
	\item Security Parameter Index (32 bits) identifies the SA to which an incoming packet is bound.
	\item Sequence Number (32 bits) is a counter field initialized to zero, and then incremented for each datagram sent using that particular SA, therefore offering protection in case of replay attacks \cite{kozierok2005tcp}.
	\item Authentication Data (variable size in order to support different hashing algorithms, but it must be a multiple of 32 bits) contains the ICV. The entire header must be a multiple of either 32 or 64 bits, depending on the IP version used, so additional padding may be added to the Authentication Data field if necessary.
\end{itemize}			
		
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{ah_header}
			\centering
			\caption{IPsec Authentication Header (AH) format}
			\label{ah_header}
		\end{figure}
		
		\newpage
		\subsection{Placement}
		AH placement fully depends on the IPsec mode of operation (transport or tunnel) and the IP version used (IPv4 or IPv6).
		\subsubsection{IPv4}
		\begin{figure}[h]
			\includegraphics[width=\textwidth,height=0.11\textheight,keepaspectratio]{original_ipv4_packet}
			\centering
			\caption{Original IPv4 datagram.}
		\end{figure}
		
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{ah_ipv4_transport}
			\centering
			\caption{In transport mode, since only the IP payload is secured, the AH header appears between the IPv4 header (along with its options) and the next layer protocol \cite{rfc4302}.}
		\end{figure}
		
		\begin{figure}[!h]
			\includegraphics[width=\textwidth]{ah_ipv4_tunnel}
			\centering
			\caption{In tunnel mode, the whole IPv4 datagram is encapsulated and secured, AH appearing before it.}
		\end{figure}
		
		\newpage
		\subsubsection{IPv6}
		\begin{figure}[!h]
			\includegraphics[width=\textwidth]{original_ipv6_packet}
			\centering
			\caption{Original IPv6 datagram, including Routing Extension Header and Destination Options Extension Header, with TCP as the upper layer protocol.}
		\end{figure}
		
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{ah_ipv6_transport}
			\centering
			\caption{In the transport mode, AH is usually inserted before the transport layer and IPv6 destination options extension headers, although the latter might also come before \cite{rfc4302}.}
		\end{figure}
		
		\begin{figure}[!h]
			\includegraphics[width=\textwidth]{ah_ipv6_tunnel}
			\centering
			\caption{AH in tunnel mode.}
		\end{figure}
	
		
		\subsection{ICV Computation}
		The ICV is calculated over the majority, but not the entire IP datagram. Fields which are modified in transit between the two gateways must be excluded in order for the receiving IPsec peer to not mistakenly discard the packet (remember that even if a single bit is changed the ICV values will differ). An example is the time to live (TTL) field in the IPv4 header, which is decremented at each hop until the datagram reaches its destination, or until it reaches zero, in which case the datagram is discarded. With this in mind, the AH ICV is computed over the following:
		\begin{itemize}
			\item Everything after the AH header. In transport mode, this is represented by the transport layer message, which definitely should not change. In tunnel mode, this also includes the inner IP header, which again must remain unchanged (remember that in tunnel mode, between the IPsec endpoints, only the outer IP header is changed and inspected by intermediary nodes).
			\item The AH header (with the ICV initially set to zero).
			\item IP or extension headers fields before the AH header that are immutable in transit. For example, in IPv4, the DSCP, ECN, flags, fragment offset, TTL and header checksum fields are excluded, since they might be changed by routers.
		\end{itemize}
	
		\subsection{NAT Incompatibility}
			A considerable disadvantage of AH is that it is incompatible with Network Address Translation (NAT). As previously explained, the AH header incorporates the IP source and destination addresses in the ICV computation. If one of the IPsec gateways is inside a private network, as is usually the case, the ICV will be calculated over a private IP address. Just as the packet leaves into the public network, Network Address Translation (NAT) will inevitably modify the IP header in order for it to contain only public addresses, therefore invalidating the ICV. Although some methods to bypass NAT in case of AH packets exist \cite{rfc3715}, they are quite limited. Fortunately, integrity can also be provided by ESP. IPsec ESP tunnels do not cover the outer IP header within the message integrity check, and so will not cause problems with address translation.
			
		\section{Encapsulating Security Protocol}
		\subsection{Description}
		IPsec AH provides integrity services to IP datagrams, guaranteeing that the packets received by the IPsec peers are intact and not maliciously altered in transit. However, for most applications, this is only one small piece of the puzzle. Although potential eavesdroppers would not be able to change the intercepted IP datagrams, they still can examine their contents. This includes the authentic IP addresses of the communicating peers (present in the only IP header in transport mode, and in the inner IP header in tunnel mode), as well as the transport data, which probably contains the most valuable information in a network packet, such as HTTP data. Therefore, for perfect privacy, AH is clearly not enough. This is where IPsec ESP steps in.
		
		Encapsulating Security Payload (ESP) is the second core protocol of the IPsec suite, and probably the most versatile, implementing a mix of security services in IPv4 and IPv6. ESP can be configured to provide only confidentiality, only integrity, or both at the same time \cite{rfc4303}.
		
		ESP can be used in conjunction with AH as well, the first one providing confidentiality while the latter guarantees integrity. However, since ESP can implement both services (i.e. the packets will be protected with regard to confidentiality and integrity), AH is deemed unnecessary in most situations.
		
		\subsection{Format}
		ESP provides confidentiality to IP datagrams by encrypting them. To achieve this, ESP defines a special format in which it repackages an original IP datagram. Instead of having just a header and a payload, ESP fields are divided into four components:
		\begin{itemize}
			\item \textbf{ESP Header.} This contains the SPI and Sequence Number fields, and comes before the encrypted data.
			\item \textbf{ESP Payload Data.} The data encapsulated by ESP, in encrypted form. Depending on the mode of operation employed, this is either a transport layer message (transport mode) or an entire IP datagram (tunnel mode). Since some encryption schemes also require an Initialization Vector (IV), this is added in plaintext at the beginning if needed.
			\item \textbf{ESP Trailer.} This section is placed after the encrypted data and contains padding and two fields, Pad Length and Next Header. Padding is required in order to support encryption algorithms that require the data to have a certain block size. The Pad Length field indicates the padding size, in order for the receiver to clearly separate the original message from the padding. Next Header contains the protocol number of the next header in the encapsulated payload.
			\item \textbf{ESP Authentication Data.} This is optional, representing the ICV value if ESP is also used for integrity services. Unlike AH, the ICV is calculated only over the ESP header, payload and trailer, not including the outer IP header in tunnel mode. However, this avoids the issue previously mentioned when employing AH over NAT.
		\end{itemize}
		
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{esp_format}
			\centering
			\caption{ESP Fields Format.}
		\end{figure}
		
		\newpage
		\subsection{Placement}
		\subsubsection{IPv4}
		
		\begin{figure}[h]
			\includegraphics[width=\textwidth,height=0.15\textheight,keepaspectratio]{original_ipv4_packet}
			\centering
			\caption{Original IPv4 datagram with TCP as the upper layer protocol.}
		\end{figure}
		
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{esp_ipv4_transport}
			\centering
			\caption{In transport mode, the ESP header and trailer surround and secure the transport layer message.}
		\end{figure}
		
		\begin{figure}[!htb]
			\includegraphics[width=\textwidth]{esp_ipv4_tunnel}
			\centering
			\caption{In tunnel mode, ESP encapsulates and protects the entire original IPv4 datagram.}
		\end{figure}
\newpage
		\subsubsection{IPv6}
		\begin{figure}[!htb]
			\includegraphics[width=\textwidth,height=0.15\textheight,keepaspectratio]{original_ipv6_packet}
			\centering
			\caption{Original IPv6 datagram, including Routing Extension Header and Destination Options Extension Header, with TCP as the upper layer protocol.}
		\end{figure}
		
		\begin{figure}[!htb]
			\includegraphics[width=\textwidth]{esp_ipv6_transport}
			\centering
			\caption{In transport mode, ESP protects the upper layer message, in some cases along with the IPv6 destination options extension headers \cite{rfc4303}.}
		\end{figure}
		
		\begin{figure}[!htb]
			\includegraphics[width=\textwidth]{esp_ipv6_tunnel}
			\centering
			\caption{In tunnel mode, ESP protects the entire original IPv6 datagram.}
		\end{figure}
	\newpage
		\subsection{NAT Traversal}
		ESP has its own incompatibility issues with NAT, although not quite as serious as AH. Aside from changing the private IP address with a public one, NAT also changes the TCP/UDP source port. This mapping between the real source port and the NAT assigned port is used to correctly identify the recipient when a response packet is processed. However, as previously illustrated, ESP packets do not have TCP/UDP port numbers. A NAT device (and any other node until the receiving IPsec peer) can only examine the outer IP header and the ESP header -- everything after that is encrypted (except for the ESP Authentication Data, if present).
		
		Fortunately, unlike AH, this issue can be easily resolved by adding an UDP header between the outer IP header and the ESP header. This technique, which is also used by IKE, is called IPsec NAT Traversal and has the UDP port 4500 assigned.
		
		\chapter{GoIPsec}
		\section{Motivation}
		As previously described in the first chapters, the two core IPsec protocols (AH and ESP) are directly implemented in the kernel, with the key management (ISAKMP/IKE) application running as a daemon running in user space. While this approach guarantees maximum packet processing speed and minimum overhead, it offers quite limited flexibility. For example, if a user wanted to change the next header field (automatically set to 50 for ESP) in the outer IP header, possibly because of a firewall that does not allow ESP packets, this would require changing and recompiling the kernel, which could turn out to be not an easy task, depending on the operating system used.
		
		GoIPsec is an application which demonstrates a partial implementation of the IPsec protocol suite at software level, able to act as a VPN, offering confidentiality and integrity to network packets between two devices. Its design can be further used as a blueprint for many application architectures, such as VPNs with specific security requirements, custom made network protocols or deep packet inspection firewalls.
		
		\section{Architecture}
		GoIPsec was developed from the standpoint of a casual user wishing to secure network traffic when accessing different servers through the Internet, as shown in figure \ref{topology}. In order to do so, two GoIPsec gateways are needed -- one client-side and another one server-side. The client will use the first one as a proxy, which will apply security services to network packets, such as encryption. These packets will be then routed through the public network to the server-side gateway, responsible with decrypting the packets and forwarding them to the corresponding server. The server's response will be then received by the server-side gateway, and the roles are interchanged (i.e. the server-side gateway encrypts packets and the client-side decrypts them).
		
		In this architecture, the network packets are secured between the two gateways. Moreover, if someone were to intercept traffic between the server-side gateway and one of the servers, its origin would point to gateway, not to the actual client. Packets are vulnerable only between the client and the client-side gateway, which is why these two should be directly linked, preferably through an Ethernet cable (remember that radio waves, such as those used by Wi-Fi, can easily be hijacked). Therefore, the client-side gateway could be something small and portable, such as a Raspberry Pi device, while the server-side could be hosted in the cloud, possibly in another region in order to bypass geo-blocking.
		\begin{figure}[h]
			\includegraphics[width=\textwidth]{goipsec_setup}
			\centering
			\caption{GoIPsec network topology.}
			\label{topology}
		\end{figure}
		
		\section{Technologies}
		As its name suggests, GoIPsec is written in Go, an open source programming language developed at Google by Robert Griesemer, Rob Pike, and Ken Thompson. I personally find it very clean and concise, and really enjoyable for writing any kind of applications. It has a lot of similarity with C, on which it was partly based, along with many improvements, such as structural typing, garbage collection and an excellent concurrency system, while still being one of the fastest programming languages. In addition to this, Go has an exceptional standard library, with packages for cryptography, networking, image processing, encoding and many more.
		
		The major package used in developing GoIPsec is represented by gopacket, a third-party library also developed by Google, which provides network packet decoding, as well as building network packets from the ground up, supporting many protocols. It also integrates libpcap, a portable C/C\texttt{++} library for network traffic capture.
		
		Docker, a popular virtualization platform that uses containers to deliver isolated software applications is also used for building a local testing environment, in conjunction with Docker Compose.
		
		\section{Setup}
		Configuration in mainly necessary on the two gateways. Once Go\footnote{Available for any distribution at \url{https://golang.org/dl/}} and libpcap\footnote{Available at \url{https://www.tcpdump.org/}} are installed, GoIPsec, which is an open source project currently hosted on GitHub\footnote{Available at \url{https://github.com/BogdanIonesq/goipsec}} can be easily installed using Go utilities:
		\begin{lstlisting}[caption=Installing GoIPsec.]
$ go get github.com/BogdanIonesq/goipsec
		\end{lstlisting}
		gopacket can be installed in the same fashion:
		\begin{lstlisting}[caption=Installing gopacket library.]
$ go get github.com/google/gopacket
		\end{lstlisting}
		GoIPsec requires only one configuration file, in JSON format, which must be named \texttt{goipsec.json} and placed in the user-specific configuration data directory. On Unix systems, this usually is \texttt{\$HOME/.config}, unless \texttt{\$XDG\_CONFIG\_HOME} is set. An example and more information about the fields can be found below:
				\begin{lstlisting}[caption=Example of GoIPsec client-side configuration file.]
{
	"Type": "client",
	"ClientIPv4Addr": "173.17.17.10",
	"ClientIPv6Addr": "2001:db8:23:42:1::10",
	"ClientMAC": "02:42:ac:11:00:10",
	"NodeIPv4Addr": "173.17.17.20",
	"NodeIPv6Addr": "2001:db8:23:42:1::20",
	"NodeMAC": "02:42:ac:11:00:20",
	"NextHopMAC": "02:42:ac:11:00:99",
	"NextGatewayIPv6Addr": "2001:db8:23:42:1::30"
}
		\end{lstlisting}
		\begin{itemize}
		\item \textbf{Type.} Specifies if the gateway should behave client-side or server-side. Can only be set to \quotes{client} or \quotes{server}.
		\item \textbf{ClientIPv4Addr.} Client's IPv4 address (required only client-side).
		\item \textbf{ClientIPv6Addr.} Client's IPv6 address (required only client-side).
		\item \textbf{ClientMAC.} Client's MAC address (required only client-side).
		\item \textbf{NodeIPv4Addr.} Current device's IPv4 address.
		\item \textbf{NodeIPv6Addr.} Current device's IPv6 address.
		\item \textbf{NodeMAC.} Current device's MAC address.
		\item \textbf{NextHopMAC.} MAC address of the next device when routing packets. Can be found with the \texttt{ip neighbor} command.
		\item \textbf{NextGatewayIPv6Addr.} IPv6 address of the other GoIPsec gateway.
		\end{itemize}
		
		In order to provide confidentiality and integrity services, a cryptographic key shared by the two gateways is needed. GoIPsec retrieves it from the \texttt{GOIPSEC\_KEY} environment variable, which therefore must be set and must have a length of exactly 32 bytes. A quick and simple method to safely generate a random set of 32 characters (which equals 32 bytes) and assign it to the corresponding environment variable is the following:
		\begin{lstlisting}[caption=Randomly generate \texttt{GOIPSEC\_KEY}.]
$ export GOIPSEC_KEY=\
	$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32)
		\end{lstlisting}
		Finally, to compile and run GoIPsec, navigate to the \texttt{cmd/goipsec/} directory and run \texttt{main.go}:
		\begin{lstlisting}[caption=Compile and run GoIPsec.]
$ cd cmd/goipsec/
$ go run main.go
		\end{lstlisting}
		Once the two GoIPsec gateways are up and running, all the client needs to to is to route some or all of his traffic through the client-side gateway in order for it to be secured. This is done with the help of the \texttt{ip} command.
				\begin{lstlisting}[caption=Route IPv6 traffic destined for \texttt{2001:db8:23:42:1::40} through the GoIPsec gateway available at \texttt{2001:db8:23:42:1::20}.]
$ ip -6 route add 2001:db8:23:42:1::40/128 via 2001:db8:23:42:1::20
		\end{lstlisting}
\newpage
			\begin{lstlisting}[caption=Route all IPv4 traffic through the GoIPsec gateway with address \texttt{173.17.17.99}.]
$ ip route add default via 173.17.17.99
		\end{lstlisting}
		
		However, if a user does not have access to another two servers on which to run GoIPsec, or wishes to use GoIPsec for testing or educational purposes, the Docker setup if more than enough. This resides in the \texttt{deployments/} folder, where the \texttt{docker-compose.yml} file describes the multi-container platform administrated by Docker Compose. In addition, the \texttt{dockerfiles/} folder contains the setup for each one of the containers, while the \texttt{logs/} directory contains the network traffic dump files associated.
		
		In order to use the Docker setup, after installing Docker and Docker Compose, support for IPv6 must also be enabled by setting the \texttt{ipv6} key to \texttt{true} in \texttt{/etc/docker/daemon.json}, followed by reloading the configuration file:
		\begin{lstlisting}[caption=Contents of \texttt{/etc/docker.daemon.json} in order for Docker to have IPv6 capabilities.]
{
  "ipv6": true
}
		\end{lstlisting}
				\begin{lstlisting}[caption=Reload Docker configuration file., language=bash]
$ systemctl reload docker
		\end{lstlisting}
		After modifying the volume paths in the \texttt{docker-compose.yml} file, the Docker Compose platform is ready to run:
		\begin{lstlisting}[caption=Run Docker Compose setup.]
$ cd deployments/
$ docker-compose up
		\end{lstlisting}
		
		\section{Workflow}
		The steps GoIPsec implements in order to secure a given network packet from the client to one of the server are as follows:
		\begin{enumerate}
		\item At launch, GoIPsec first checks the \texttt{goipsec.json} configuration file. If no errors occur, the information is saved in a structure, being vital for the next steps. The environment variable \texttt{GOIPSEC\_KEY} is also verified, confirming that it is set and has a length of exactly 32 bytes.
		\item The GoIPsec gateway starts listening for specific network traffic, depending on the type defined in the configuration. A client-side gateway will capture TCP and UDP traffic from the client, and UDP packets with destination port 4500 from the other GoIPsec gateway. A server-side gateway will capture all TCP and UDP traffic, deciding later if a particular network packet is secured by another GoIPsec device or if it is a response from one of the servers.
		\item When the client-side gateway receives an IP datagram from the client, GoIPsec secures it by following ESP specifications. Firstly, an ESP header and trailer are added. Secondly, everything except the ESP header is encrypted with AES-256 in CBC mode using \texttt{GOIPSEC\_KEY} as the cipher key. Then, integrity is assured by adding authentication data at the end, computed with HMAC-SHA512/256. All of this is UDP encapsulated with destination port 4500, then IPv6 encapsulated. The IPv6 destination address is the one of the server-side gateway, guaranteeing that the packet is routed to it.
		\item When the server-side gateway receives this packet, it computes its own ICV using the same algorithm and key, and compares it with the ESP Authentication Data. If the values differ, the packet is discarded. Otherwise, the ESP Payload Data is decrypted, obtaining the original IP datagram from the client. This is also slightly modified, changing the source IP address with that of the gateway and recalculating the checksum accordingly.
		\item If the server-side gateway receives a response from a server, the roles are interchanged, meaning the server-side GoIPsec device will encrypt the packet, then the client-side gateway will decrypt it and forward it to the client.
		\end{enumerate}
		
		Following Go programming conventions, all of these functions are available as packages, located in the \texttt{pkg/} directory. Gateway is the main package, providing necessary configuration, encryption and decryption, while others have miscellaneous purposes, such as checksum calculation for UDP and TCP, and logging mechanisms.
		
		\chapter{Conclusion}
		Using the Internet, or any other public network, does not come without accountability for potential security threats. Unfortunately, because of the outstanding growth of such networks, in both number of users and amount of data available, one must take additional precautions and efforts in order to achieve security.
		
		Systems specifically built for these purposes already exist, especially in the form of network protocols, which adapt to almost any security needs. Such effective solutions are usually composed of many working parts, and their complexity can sometimes baffle inexperienced users. However, a closer look proves that every piece has its own crucial function, adding support for any requirement.
		
		Many solutions also exist from a programming point of view, allowing those with such knowledge to implement their own applications. Nevertheless, new security vulnerabilities and attack are discovered each day, and therefore both sides must remain vigilant and informed. 
% Print bibliography
\bibliographystyle{abbrv}
\bibliography{bibliography}


\end{document}